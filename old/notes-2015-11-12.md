While you're waiting for the meeting to start, please take a moment and read http://software-carpentry.org/pages/audience.html

**11:00 UK time**

* Greg Wilson
* Kai Blin
* Peter van Heusden
* Elita Baldridge
* Stefano Menegon
* Patrick Chapman
* Bérénice Batut
* Felipe Bocca
* Lukas Weber
* Moritz Neeb
* Steve Crouch
* Jon Badalamenti
* Juan Ugalde
* Jane Charlesworth

**19:00 UK time**

* Joanna Jedrzejewska-Szmek
* Keith Ma
* Natasha Pavlovikj
* Joaquín Morís
* Jennifer Nafziger
* Patricia Vera
* Luciano Issoe
* Christina Koch
* Jingchao Zhang
* Melisa Guzman
* Grzegorz Haranczyk
* Holly Murray
* Andreas Mueller
* Tobin Magle
* Ahmed Moustafa
* Karin Lagesen
* Sean Barberie
* Tina O'Grady
* Bill McClung
* Jin Choi
* Toby Hodges
* Edwin van der Helm
* Sigrid Klerke
* Rochelle
* Jillian
* Michelle Craft
* Eric Ma
* Steve Van Tuyl
* Jackie Milhans
* Sonia Suarez (I still can't login into the room)
* Catherine Olsson
* Tomomi Sunayama
* Nada Ghanem

**Notes on Live Coding**

* Do you think that live coding requires more prep, less prep, or about the same compared to teaching with slides?
  * Less preparation, because you seem not to prepare the content so much, only in which steps you talk about it
    * It encourages improvisation. Can make up examples "on the spot."
  * Different prep. I'd say about same as slides - time is spent on preparing the coding environment, not polishing the slide deck.
    * I constantly adjust slides, so there is always prep for teaching.
    * For live coding, there is need to prepare example notebooks, for instance.
      * One issue is that live coding doesn't necessarily capture all the discussions that happens around the code created.
  * Depends on how well you know the subject matter <- slides force you to create structure.
  * More and different preparation 
    * Need to think to specific "example", easy to do in live coding without doing to much mistakes
    * With presentation, you could have a "backup" that you do not have with live coding
  * I agree, it's about the same but different.
    * I need to make sure the learning objectives are clearer on slides, so they still make sense later.
    * For live coding, I need to better track the time I'm spending.
  * about the same, but type of prep is different
    * slides can/often do have more examples; slides can also contain additional information, but live coding requires clearly presenting every step from start to finish - nothing can really be glossed over +1 (Eric)
  * About the same: in different ways
  * I think same amount of effort. For me definately less prep, but it would depends on the topic you teach.
  * More preparation, and different as you don't have feedback
  * I always prep way more for live coding - mistakes are very obvious (although it's good for the students to see). You can bluff with slides!
  * More first, but less if known stuff
  * It is more difficult to judge when you have fully prepared for live coding, versus slides
  * More prep, and different, but at the same it is easier to remember from one time to the next
  * Different prep - I needed to be sure that I could field a wider variety of questions, 
    * so i needed to understand pretty deeply how what i was presenting worked
    * i could imagine this being less prep in the long-term (with practice, etc.)
  * I think that with slides, it takes less preparation to do a mediocre job and narrate them, but harder to do a *good* job, as compared to live coding. You can't bullshit live coding with no prep the way you can bullshit slides with no prep. But if you're willing to put in the preparation, you can get a lot more mileage from the interactive format.
  * I think you have to be more focused. It's easy to stray when you can esentially do anything. Definitely need more understanding.
  * 
  * Sometimes there is more 'after prep' to cleanup what was done in class.
  * More prep since I need think the logics between different sessions.
  * I think it's about the same amount of prep but allows you to be much more adaptable about what you teach, which could reduce the prep time in real terms - allows you to react to requests for more info, tangential topics/discussion etc.
  * I think it's the same amount, maybe a bit less. Most of my time is spend on structuring the lecture, deciding what to include and practicing timing. For slides I usually make one diagram per slide, and making good diagrams takes a lot of time.

**What tips did we learn from the exercise?**

* Gregs experience in another iteration of this course: Live coding as first exercise, to get to know each other. This failed because people didn't know each other yet.
* Less prep for teaching but the instructor must have a better overall understanding of the material (harder to fake it). And yes, in some sense that time spent 
* Tip from Greg: perform (type code, and speak out loud as you type it) once, then step away and review what you've done - this slows things down a bit
* Pause before hitting enter on a command, every time
* Type extremely, excruciatingly slowly. Try typing with just one hand.
* Prepare/practice what you're going to say about each line, so you know what phrasings you want to use.
* Start and end with a declaration of your learning objectives, or specifically, what you're trying to achieve as an example user, and what you just achieved and how
* Intermediate summaries are useful

**Notes on Assessment**

* Nobody is happy with the questionnaire, but best we have.
* Goal was: to get an overview of the audience.
* The questions are intimidating - including them in the registration process puts people off doing the course
  * need to be really careful that the questionnaire doesn't cause people to drop out or change their mind about registering
* Response rates to pre-assessment questionnaires are currently low - how can we increase them?
* Designing a new questionnaire requires going back and evaluating responses - how accurate are people's self-assessments?
* But designing a new questionnaire which is accurate is a complicated, iterative process - self-assessment must be calibrated with the actual answers people give and followed up with interviews.
* However without accurate questionnaires, no way of assessing what was learned (though at least lots of anecdotal evidence!).

**Learner Profiles**

* See http://software-carpentry.org/pages/audience.html for ours
* What are yours?
* Background: Software Agencies in UIX Design "create" some people to have to check their standards.
* Current profiles biased towards top end - more advanced than most of our students
* What will be different in the tools they use (other dimensions?)
* Uncommon to have them in academia, but more common in professional trainings

**Motivation**

* People learn best when both:
  * they care about the topic
  * they believe they can master it
* Which can be a problem
  * Most scientists don't want to program: they want to do science
    * "if a wanted to be a programmer..., would've taken that path"
    * for many, programming is a tax they have to pay
    * have to show them that they a. that it will help them do more and b. that they can do it
    * aren't these not mutually exclusive? they are if your 'main' job is in wet lab yes, good point! or even if you're working on the computer but pressured to deliver instead of 'polishing' code
  * Early experiences with programming are often demoralizing
    * jargon-heavy. "it's obvious"
    * some people are introduced to languages like Pascal, Java, etc and intimidating classes. (this is from different generations of high school programming classes)
  * Believing that something will be hard to learn is a self-fulfilling prophecy
* Teach the most immediately useful topics first
  * Where "time to usefulness" includes actual setup times
  * may not even teach things that are useful in the long run, but just anything that will "sell" them on programming
  * Need to offer something learners believe they will actually do. Builds confidence, means learners will invest to get to next pay-off - should be authentic tasks
  * The faster you can get to useful tasks (from the scientist's point of view), the better.
* Example: media-first computation
  * instead of "Hello World": open image, resize, save as thumbnail.
  * Advantages - a practical excersice that poeple will use, makes it obvious where the mistake has happened (if any)
  * especially beneficial for demographics who haven't been had as much access to coding education before
* Programming has very different applications. The motivation to learn depends also on your social "peer group", on "what is cool"
  * e.g. Programming games is "cool" for kids
  * e.g. programming scripts in a graphics program cool for Artists
* Teach intro programming for biologists by starting with plotting, loading data sets (i.e. immediately useful tasks) - helps motivate students.

**Strategies Checklist (from "How Learning Works")**

* Strategies to establish value
  * Connect the material to students' interests
  * Provide authentic, real-world tasks
  * Show relevance to students' current academic lives
  * Demonstrate the relevance of higher-level skills to students' future professional lives
  * Identify and reward what you value
  * Show your own passion and enthusiasm for the discipline
* Strategies to build positive expectations
  * Ensure alignment of objectives, assessments, and instructional strategies
  * Identify an appropriate level of challenge
  * Create assignments that provide the appropriate level of challenge
  * Provide early success opportunities
  * Articulate your expectations
  * Provide rubrics
  * Provide targeted feedback
  * Be fair
  * Educate students about the ways we explain success and failure
  * Describe effective study strategies
* Strategies for self-efficacy
  * Provide flexibility and control
  * Give students an opportunity to reflect

**Demotivation**

* Not demotivating learners is at least as important as motivating them
* Biggest demotivators are *indifference* and *unfairness*
  * belief that no-one cares or that the game is rigged will cause people to give up. 
  * All sorts of things can feel 'unfair' - software won't install, feeling overlooked, unable to have an accommodation that has been requested
* Biggest question is, what do you do after something's gone wrong?
  * Everyone makes mistakes - but what do you do afterwards?
  * Be fair and care.

**Homework**

1. Describe something you do in your daily work that uses one or more of the skills we teach (Shell, python, etc), and explain how you would use it (or a simplified version of it) as an exercise or example in class.  (Authentic story that puts the pieces together)
1. Write a paragraph or two about something that happened in your educational career that demotivated you, and explain what could have been done afterward to fix it.
1. Write a before-and-after learner profile based on http://software-carpentry.org/pages/audience.html.
